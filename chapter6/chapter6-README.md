# chapter 6
人間相手のプログラミングー端末制御とシグナル

ブロッキング入力とノンブロッキング入力
plain_againサンプルでは、プログラムはユーザが文字を入力するまでじっと待ち続ける。
（プログラムがブロックされる。）
入力待ちのブロックをオフにするにはどうすればよいのだろうか。

ブロックは、端末接続だけではなく、あらゆるオープンファイルのプロパティである。そして、
fcntl, openを使えば、ファイルディスクリプタに対してノンブロッキング入力を有効にすることができる。
例では、fcntlを使ってファイルディスクリプタの O_NDELAY(O_NONBLOCK)フラグをオンにする。


シグナル
Ctrl+Cの仕組み
1. ユーザがCtrl+Cを押す
2. ドライバ(tty)が文字を受け取る
3. 文字がVINTRに一致するので、ISIGがオンになる
 [makoto@BSD ~/repos/uulp/chapter6]$ stty -a | grep intr | sed -e "s/.*intr =//" | sed -e "s/;.*//"
  ^C
4. ドライバがシグナルシステムを呼び出す
5. シグナルシステムがプロセスにSIGINTを送る
6. プロセスがSIGINTを受け取る
7. プロセスが死ぬ

シグナルの３つの源
・ユーザーキーストロークからのシグナル
・例外からのシグナル
・他のプロセスからのシグナル


次は何か
　Unixマシンは始終多くの端末や他のデバイスからデータを受信している。ユーザは予測不能なタイミングで
端末データを生成するが、カーネルはそれらのキーストロークを処理しなければならない。
また、Unixマシンは複数のプログラムを実行しなければならない。カーネルはどのようにして複数のことの同時実行を管理し、
複数の予測不能な割り込みに応答しているのか。私たちは、ビデオゲームを書いてこの問題を考えていく。
